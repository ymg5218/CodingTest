# 1701

# 문자열 중, 2번 이상 반복되는 부분 문자열들 중에서 가장 긴 부분 문자열 찾기

'''
참고 : https://bowbowbow.tistory.com/6
KMP(Knuth-Morris-Pratt) 알고리즘 : 문자열 패턴 매칭 알고리즘
부분 문자열(패턴)의 길이를 M, 전체 문자열의 길이가 N
1. 한 칸씩 밀면서 매칭되는지 검증하는 시간복잡도 : O(NM)
2. KMP 알고리즘 사용 : O(N+M)

KMP 알고리즘 이해를 위한 2가지 : 접두사 - 접미사 , pi 배열
ex) aabaa
1. 접두사 - 접미사
접두사
- a
- aa
- aab
- aaba
- aabaa

접미사
- a
- aa
- baa
- abaa
- aabaa

2. pi 배열
pi[i] : 주어진 문자열의 0~i 까지의 부분 문자열 중에서 접두사 == 접미사 가 될 수 있는 부분 문자열 중에서
가장 긴 것의 길이 (이 때, 접두사가 0~i 까지의 부분 문자열과 같으면 안 됨.)
i   부분 문자열 pi[i]
---------------------
0       a        0
1       aa       1        
2      aab       1
3      aaba      1
4     aabaa      2
'''

'''
내 예상 풀이
1. 접두사/접미사의 길이를 1씩 늘려가며 매칭 여부를 판단한다.
2. 만약 매칭되면 매칭되었을 때의 부분 문자열 길이를 저장한다.
3. 접두사/접미사가 전체 문자열 길이만큼까지 증가되어 모두 탐색했을 때,
    앞에서부터 문자를 하나씩 지우며 다시 탐색한다.
4. 모든 사이클을 돌리며 가장 길이가 길었던 문자열의 길이를 저장하고 출력한다.
'''

# str = input()
# temp_str = ""
# max_len = 0

# # O(n^2)
# def KMP(str):
#     global max_len
#     for i in range(1,len(str) - 1):
#         # print(str[0 : i],str[-i :])
#         if str[0 : i] == str[-i :]:
#             max_len = max(max_len, i)

# temp_str = str

# # 앞에서 부터 하나씩 없애며 접두사 == 접미사 케이스 중, 가장 길었던 경우 추출
# # 문자를 하나하나 삭제하며 진행 => 반복 횟수 n(n+1)/2 ~ n^2
# # 총 복잡도 : O(n^4) 시간초과 날 만 했다
# while(len(temp_str) != 0):
#     # print("차례 : ",temp_str)
#     KMP(temp_str)
#     temp_str = temp_str[1:len(temp_str)]

# # 뒤에서 부터 하나씩 없애며 접두사 == 접미사 케이스 중, 가장 길었던 경우 추출
# # 문자를 하나하나 삭제하며 진행 => 반복 횟수 n(n+1)/2 ~ n^2
# # 총 복잡도 : O(n^4) 시간초과 날 만 했다
# temp_str = str
# while(len(temp_str) != 0):
#     # print("차례 : ",temp_str)
#     KMP(temp_str)
#     temp_str = temp_str[0 : len(temp_str) - 1]
# print(max_len)

'''
위 방법은 시간초과가 났음 (O(n^4))
내가 간과한 것 : KMP 알고리즘의 핵심 비법
패턴을 비교하는 과정에서, 틀렸더라도 패턴의 부분이 일치했다면, 그 정보를 십분 활용해 검색 속도를 개선하겠다!

해결 방안 : 실패함수를 작성, pi배열을 채운다.
실패함수에 대한 자세한 풀이는 따로 그림 설명

내 예상 풀이는 복잡도 O(n^2) 예상
'''

str = input()

max_len = 0 # 원하는 해를 담을 변수

# 실패함수 : 시간복잡도 O(n)
def failure(str):
    pi = [0] * len(str)
    i = 1
    j = 0
    
    # 복잡도 O(n), n은 문자열의 길이
    while(i < len(str)): # i의 범위가 str의 길이를 넘기지 않을 때까지 반복
        if str[j] == str[i]: # 문자열의 j번째 인덱스와 i번째 인덱스가 일치할 때
            j += 1 # j값 1 증가
            pi[i] = j # pi[i] 에 1만큼 증가시킨 j 값 삽입
            i += 1 # i값 1 증가
            
        elif str[j] != str[i]: # 문자열의 j번째 인덱스와 i번째 인덱스가 일치하지 않을 때
            if j > 0: # j가 0보다 큰 인덱스를 가리키고 있다 + 일치하지 않는다
                j = pi[j - 1] # j의 위치를 pi[j - 1]번째 인덱스로 이동 
                # 이 기능이 KMP 알고리즘의 핵심이라 생각
                '''
                1. 탐색중인 문자열에서 매칭 시도하는 패턴이 앞에서부터 일치하고 있다.
                2. 어느 순간 일치하지 않는 문자가 등장하면 패턴을 한 칸 미는 것이 아닌, 직전까지 매칭되던 정보를 이용하는 것
                3. 패턴의 j번째 문자열이 매칭되는지 비교중이었는데, 매칭이 실패했다면  j를 1만큼 차감해 이전 문자열로 롤백
                4. 패턴의 첫 번째 문자~ j-1번째 문자열을 잘라서 부분문자열로 생각해보자. pi[j-1] = 2라면, 해당 문자열의 접두사 == 접미사 길이는 2이다
                5. 따라서, 패턴을 한 칸만 밀지 말고, 접미사 자리에 접두사가 오도록 패턴을 쫙 밀어버리는 것이 가능하다는 것이다.
                6. 해당 방법을 이용해 시간복잡도를 O(n)까지 줄이는 것이 해당 알고리즘의 핵심
                '''
            else: # j가 0번째 인덱스를 가리키고 있다 + 일치하지 않음
                pi[i] = j # pi[i]에 j값인 0 대입
                i += 1 # i를 1 만큼 증가
    
    return max(pi) # 최종적으로 구한 pi배열에서 가장 큰 요소를 return 한다.
'''
이제 문자열을 앞에서부터 하나하나 자르면서 failure 함수를 실행한다.
모든 경우의 수 문자열에서 도출되는 pi배열 요소 값 중, 가장 큰 값을 계속 비교하여 갱신시킨다.
최종적으로 도출된 가장 큰 값이 이 문제가 원하는 해가 될 것
'''
# 최종 시간복잡도 : O(n^2)
for idx in range(len(str)):
    max_len = max(max_len , failure(str[idx:]))

print(max_len)




