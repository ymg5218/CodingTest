# 1612

# 비슷한 문제 : https://www.acmicpc.net/problem/4375  -> 백준 4375

'''
 1 => 1,11,111,1111 ...
 2 => 불가능
 3 => 111 111111 ... 
 4 => 불가능 (2의 배수)
 5 => 불가능
 6 => 111111 ... (3의 배수이면서 모든 자리수의 합이 짝수)
 7 => 111111 ...
 8 => 불가능 (2의 배수)
 9 => 3의 배수 : 가능
 .
 .
 .
 
 2와 5의 배수는 불가능하다
'''


N = int(input())

# if N % 2 == 0 or N % 5 == 0: # 2, 5의 배수라면 불가능
#     print(-1)
#     exit()

num = 0 # 모든 자릿수가 1로 이루어진 양의 정수
cnt = 1 # num의 자릿수

'''
단순하게 N의 모든 배수를 대조해서 비교하면 시간초과가 날 뿐더러 비교되는 정수의 자릿수가 엄청 커질 위험이 있음.
ex) num = num * 10 + 1 을 통해 모든 자릿수가 1로 이루어진 정수를 자릿수 증가시켜 num에 계속 갱신시켜줄 수 있지만, num이 ㅈㄴ커짐

참고 : https://merry555.tistory.com/m/13

1 % 7 = 1
11 % 7 = (1 * 10 + 1) % 7 = (1 % 7 * 10 + 1) % 7 = (1 * 10 + 1) % 7 = 4  ==> 1 mod 7의 결과를 이월시킴
111 % 7 = (11 * 10 + 1) % 7 = (11 % 7 * 10 + 1) % 7 = (4 * 10 + 1) % 7 = 6 ==> 11 mod 7의 결과를 이월시킴
.
.
.

계속 mod한 결과를 이월시키며 숫자가 기하급수적으로 커지는 것을 방지하고자 함.

이런 방식으로 N 으로 나눈 나머지는 0 ~ N-1 범위 안에 있기 때문에 최대 N번 반복하면 문제의 정답을 찾을 수 있음. -> O(N)

'''

while(1):
    num = num * 10 + 1 # 모든 자릿수가 1로 이루어진 양의 정수
    num %= N # 나머지연산 값 도출
    if num == 0: # 만약 나머지연산 결과가 0이라면 : 배수 확정
        print(cnt) # 1로 이루어진 양의 정수이자, N의 배수인 정수의 자리수 출력
        break
    cnt += 1 # 자릿수 값 1 증가
    if cnt >= N: # 만약 N번 반복해서 찾지 못했다면 -1 출력
        print(-1)
        break




