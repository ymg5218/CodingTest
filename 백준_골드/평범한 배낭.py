# 12865

'''
내 예상 풀이
1. 물건의 무게 배열 weight, 물건의 가치 배열 price 선언
2. weight, value 배열에 각각 입력받는 물건의 정보를 기입(무게, 가치)
3. knapsack 함수 호출.
    3-1 dp 선언. size는 (K+1) x (N+1), 모든 요소는 0 로 초기화.
        3-1-1. dp의 행은 현재까지 넣은 물건의 개수
        3-1-2. dp의 열은 현재 베낭의 무게 상태
        3-1-3. dp[행][열]은 현재까지 넣은 물건들의 최대 가치 합
    3-2. dp[1][1]부터 수행, 0행과 0열은 무시하고 진행해야 한다.
        3-2-1. 0행은 물건을 0개 넣는다는 뜻으로, 0행 요소는 모두 0으로 둠
        3-2-2. 0열은 베낭의 한도 무게가 0이라는 뜻으로, 아무것도 못 넣으니 모두 0으로 둠
    3-3. 현재 넣으려는 물건을 넣을 수 없다면, 직전 베낭 상태의 최대 가치값 (dp[행 - 1][열])을 dp[행][열]에 대입
    3-4. 현재 넣으려는 물건을 넣을 수 있다면
         dp[행][열 - 1] 값과
         이전 상태의 베낭에 들어있는 물건의 개수(행 = 행 - 1)에서, 현재 넣으려는 물건의 무게만큼 확보해놓은(열 = 열 - 물건의 무게) 상태의 최대 가치 + 넣을 물건의 가치
         이 두 값 중, 큰 값을 채택하여 dp[행][열]에 대입
    3-5 dp의 마지막 요소까지 해당 작업을 실시한다.
4. 마지막 dp 요소를 출력한다.
        
'''

def knapsack(N,K):
    global weight, value
    dp = [[0 for _ in range(K+1)] for _ in range(N+1)]
    for i in range(1,N+1):
        wi = weight[i] # wi : 현재 베낭에 넣어보려는 물건의 무게
        vi = value[i] # vi : 현재 베낭에 넣어보려는 물건의 가치
        for w in range(1,K+1):
            if wi > w: # 현재 넣으려는 물건을 넣을 수 없다면, 위쪽 값을 dp[i][w]에 삽입
                dp[i][w] = dp[i-1][w]
            
            # 현재 베낭 상태에, 넣으려는 물건을 넣을 수 있다면
            # max(왼쪽, 베낭에 있는 물건 개수 -1 (i - 1)인 상태에서, 물건 무게 wi를 뺀 상태에서 최대 가치 + 새로넣을 물건의 가치 v1)
            else: 
                dp[i][w] = max(dp[i - 1][w], dp[i - 1][w - wi] + vi)
                
    print(dp[N][K])


if __name__ == "__main__":
    N,K = map(int,input().split())
    weight = [-1]
    value = [-1]
    
    for _ in range(N):
        W,V = map(int,input().split())
        weight.append(W)
        value.append(V)

    knapsack(N,K)
