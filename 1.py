# 1612

# 비슷한 문제 : https://www.acmicpc.net/problem/4375  -> 백준 4375

'''
 1 => 1,11,111,1111 ...
 2 => 불가능
 3 => 111 111111 ... 
 4 => 불가능 (2의 배수)
 5 => 불가능
 6 => 111111 ... (3의 배수이면서 모든 자리수의 합이 짝수)
 7 => 111111 ...
 8 => 불가능
 9 => 3의 배수 : 가능
 .
 .
 .
 
 2와 5의 배수는 불가능하다
'''

'''
참고 : https://merry555.tistory.com/m/13

1 % 7 = 1
11 % 7 = (1 * 10 + 1) % 7 = (1 % 7 * 10 + 1) % 7 = (1 * 10 + 1) % 7 = 4  ==> 1 mod 7의 결과를 이월시킴
111 % 7 = (11 * 10 + 1) % 7 = (11 % 7 * 10 + 1) % 7 = (4 * 10 + 1) % 7 = 6 ==> 11 mod 7의 결과를 이월시킴
.
.
.

계속 mod한 결과를 이월시키며 숫자가 기하급수적으로 커지는 것을 방지하고자 함.

이런 방식으로 N 으로 나눈 나머지는 0 ~ N-1 범위 안에 있기 때문에 최대 N번 반복하면 문제의 정답을 찾을 수 있음.
'''

while(1):
    try:
        N = int(input())
    except:
        break
    num = 0 # 모든 자릿수가 1로 이루어진 양의 정수
    cnt = 1 # num의 자릿수
    while(1):
        num = num * 10 + 1 # 모든 자릿수가 1로 이루어진 양의 정수
        num %= N # 나머지연산 값 도출
        if num == 0: # 만약 나머지연산 결과가 0이라면 : 배수 확정
            print(cnt) # 1로 이루어진 양의 정수이자, N의 배수인 정수의 자리수 출력
            break
        cnt += 1 # 자릿수 값 1 증가


